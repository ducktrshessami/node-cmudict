{"version":3,"sources":["../src/install.mts","../src/error.ts","../src/util.ts"],"sourcesContent":["import { Readable } from \"stream\";\nimport { pipeline } from \"stream/promises\";\nimport { ReadableStream } from \"stream/web\";\nimport { Headers, extract } from \"tar-fs\";\nimport { createGunzip } from \"zlib\";\nimport { InstallError } from \"./error\";\nimport { CMUdictPath } from \"./util\";\n\nconst CMUdictURL = \"https://api.github.com/repos/cmusphinx/cmudict/tarball/master\";\n\nfunction flattenTar(header: Headers): Headers {\n    const index = header.name.lastIndexOf(\"/\") + 1;\n    if (index) {\n        header.name = header.name.slice(index);\n    }\n    return header;\n}\n\nconsole.debug(\"Fetching cmusphinx/cmudict\");\nconst res = await fetch(CMUdictURL);\nif (!res.ok) {\n    throw new InstallError(`Failed to fetch cmusphinx/cmudict: ${res.status} ${res.statusText}`);\n}\nconst reader = Readable.fromWeb(res.body as ReadableStream);\nconst gz = createGunzip();\nconst output = extract(CMUdictPath, { map: flattenTar });\nconsole.debug(\"Writing to ./cmudict\");\nawait pipeline(reader, gz, output);\n","class CustomError extends Error {\n    constructor(message: string) {\n        super(message);\n        this.name = this.constructor.name;\n    }\n}\n\nexport class InstallError extends CustomError { }\n","import { readFileSync } from \"fs\";\nimport { join } from \"path\";\nimport { fileURLToPath } from \"url\";\nimport { Entry } from \"./entry\";\n\nfunction getDirname(): string {\n    try {\n        return __dirname;\n    }\n    catch {\n        // @ts-expect-error\n        return fileURLToPath(new URL(\"./\", import.meta.url));\n    }\n}\n\nexport const CMUdictPath = join(getDirname(), \"../cmudict\");\n\nexport enum ArticulationManner {\n    Stop = \"stop\",\n    Nasal = \"nasal\",\n    Fricative = \"fricative\",\n    Affricate = \"affricate\",\n    Liquid = \"liquid\",\n    Semivowel = \"semivowel\",\n    Vowel = \"vowel\",\n    Aspirate = \"aspirate\"\n}\n\nexport function mapIt<T, R>(it: Iterable<T>, fn: (v: T) => R): R[] {\n    const result: R[] = [];\n    for (const value of it) {\n        result.push(fn(value));\n    }\n    return result;\n}\n\nexport function read(filename: string): string {\n    return readFileSync(join(CMUdictPath, filename), { encoding: \"utf8\" });\n}\n\nexport function readPronunciations(filename: string, pattern: RegExp): Map<string, Entry> {\n    const entries = new Map<string, Entry>();\n    for (const match of read(filename).matchAll(pattern)) {\n        const entry = entries.get(match.groups!.name) ?? new Entry(match.groups!.name);\n        match.groups!.tags\n            ?.split(\", \")\n            .forEach(tag => entry.tags.add(tag));\n        entry.addPronunciation(match.groups!.phonemes.split(\" \"), match.groups!.note);\n        entries.set(entry.name, entry);\n    }\n    return entries;\n}\n"],"mappings":"AAAA,OAAS,aAAgB,SACzB,OAAS,aAAgB,kBAEzB,OAAkB,YAAe,SACjC,OAAS,iBAAoB,OCJ7B,IAAM,YAAN,cAA0B,KAAM,CAC5B,YAAY,QAAiB,CACzB,MAAM,OAAO,EACb,KAAK,KAAO,KAAK,YAAY,IACjC,CACJ,EAEa,aAAN,cAA2B,WAAY,CAAE,ECNhD,OAAS,SAAY,OACrB,OAAS,kBAAqB,MAG9B,SAAS,YAAqB,CAC1B,GAAI,CACA,OAAO,SACX,MACM,CAEF,OAAO,cAAc,IAAI,IAAI,KAAM,YAAY,GAAG,CAAC,CACvD,CACJ,CAEO,IAAM,YAAc,KAAK,WAAW,EAAG,YAAY,EFP1D,IAAM,WAAa,gEAEnB,SAAS,WAAW,OAA0B,CAC1C,IAAM,MAAQ,OAAO,KAAK,YAAY,GAAG,EAAI,EAC7C,OAAI,QACA,OAAO,KAAO,OAAO,KAAK,MAAM,KAAK,GAElC,MACX,CAEA,QAAQ,MAAM,4BAA4B,EAC1C,IAAM,IAAM,MAAM,MAAM,UAAU,EAClC,GAAI,CAAC,IAAI,GACL,MAAM,IAAI,aAAa,sCAAsC,IAAI,MAAM,IAAI,IAAI,UAAU,EAAE,EAE/F,IAAM,OAAS,SAAS,QAAQ,IAAI,IAAsB,EACpD,GAAK,aAAa,EAClB,OAAS,QAAQ,YAAa,CAAE,IAAK,UAAW,CAAC,EACvD,QAAQ,MAAM,sBAAsB,EACpC,MAAM,SAAS,OAAQ,GAAI,MAAM","names":[]}