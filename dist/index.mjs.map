{"version":3,"sources":["../src/util.ts","../src/entry.ts","../src/index.ts"],"sourcesContent":["import { readFileSync } from \"fs\";\nimport { join } from \"path\";\nimport { fileURLToPath } from \"url\";\nimport { Entry } from \"./entry\";\n\nfunction getDirname(): string {\n    try {\n        return __dirname;\n    }\n    catch {\n        // @ts-expect-error\n        return fileURLToPath(new URL(\"./\", import.meta.url));\n    }\n}\n\nexport const CMUdictPath = join(getDirname(), \"../cmudict\");\n\nexport enum ArticulationManner {\n    Stop = \"stop\",\n    Nasal = \"nasal\",\n    Fricative = \"fricative\",\n    Affricate = \"affricate\",\n    Liquid = \"liquid\",\n    Semivowel = \"semivowel\",\n    Vowel = \"vowel\",\n    Aspirate = \"aspirate\"\n}\n\nexport function mapIt<T, R>(it: Iterable<T>, fn: (v: T) => R): R[] {\n    const result: R[] = [];\n    for (const value of it) {\n        result.push(fn(value));\n    }\n    return result;\n}\n\nexport function read(filename: string): string {\n    return readFileSync(join(CMUdictPath, filename), { encoding: \"utf8\" });\n}\n\nexport function readPronunciations(filename: string, pattern: RegExp): Map<string, Entry> {\n    const entries = new Map<string, Entry>();\n    for (const match of read(filename).matchAll(pattern)) {\n        const entry = entries.get(match.groups!.name) ?? new Entry(match.groups!.name);\n        match.groups!.tags\n            ?.split(\", \")\n            .forEach(tag => entry.tags.add(tag));\n        entry.addPronunciation(match.groups!.phonemes.split(\" \"), match.groups!.note);\n        entries.set(entry.name, entry);\n    }\n    return entries;\n}\n","export interface PronunciationData {\n    phonemes: string[];\n    note?: string;\n}\n\nexport interface EntryData {\n    name: string;\n    pronunciations: PronunciationData[];\n    tags: string[];\n}\n\nexport class Entry {\n    readonly pronunciations: Pronunciation[];\n    readonly tags: Set<string>;\n\n    constructor(readonly name: string, tags: Iterable<string> = []) {\n        this.pronunciations = [];\n        this.tags = new Set<string>(tags);\n    }\n\n    addPronunciation(pronunciation: string[], note?: string): Pronunciation {\n        const newItem = new Pronunciation(\n            this,\n            pronunciation,\n            note\n        );\n        this.pronunciations.push(newItem);\n        return newItem;\n    }\n\n    toString(): string {\n        if (this.tags && this.pronunciations.length) {\n            const first = this.pronunciations[0].toString() + ` # ${[...this.tags.values()].join(\", \")}`;\n            return [first, ...this.pronunciations.slice(1)].join(\"\\n\");\n        }\n        else {\n            return this.pronunciations.join(\"\\n\");\n        }\n    }\n\n    toJSON(): EntryData {\n        return {\n            name: this.name,\n            pronunciations: this.pronunciations.map(pronunciation => pronunciation.toJSON()),\n            tags: [...this.tags.values()]\n        };\n    }\n}\n\nexport class Pronunciation {\n    readonly phonemes: Phoneme[];\n\n    constructor(\n        readonly entry: Entry,\n        phonemes: string[],\n        readonly note: string | null = null\n    ) {\n        this.phonemes = phonemes.map(phoneme => new Phoneme(phoneme));\n    }\n\n    toString(): string {\n        return `${this.entry.name} ${this.phonemes.join(\" \")}`;\n    }\n\n    toJSON(): PronunciationData {\n        const json: PronunciationData = { phonemes: this.phonemes.map(phoneme => phoneme.toString()) };\n        if (this.note) {\n            json.note = this.note;\n        }\n        return json;\n    }\n}\n\nexport class Phoneme {\n    private static readonly Pattern = /^(?<phoneme>[A-Z]+)(?<stress>[0-2])?$/i;\n    readonly phoneme: string;\n    readonly stress: number | null;\n\n    constructor(readonly raw: string) {\n        const match = raw.match(Phoneme.Pattern)!;\n        this.phoneme = match.groups!.phoneme;\n        this.stress = match.groups!.stress ? parseInt(match.groups!.stress) : null;\n    }\n\n    toString(): string {\n        return this.raw;\n    }\n}\n","import { Entry } from \"./entry\";\nimport {\n    ArticulationManner,\n    mapIt,\n    read,\n    readPronunciations\n} from \"./util\";\n\nexport function getDict(): Map<string, Entry> {\n    return readPronunciations(\"cmudict.dict\", /^(?<name>[^\\s()]+)(?:\\((?<index>\\d+)\\))? (?<phonemes>(?:[A-Z]+[0-2]?(?:(?= #)| |$))+)(?: # (?<tags>(?:[^\\s,]+(?:$|[\\s,]+))+))?$/gmi);\n}\n\n/**\n * Maps phoneme to manner of articulation\n */\nexport function getPhones(): Map<string, `${ArticulationManner}`> {\n    return new Map<string, `${ArticulationManner}`>(\n        mapIt(\n            read(\"cmudict.phones\")\n                .matchAll(/^(?<phoneme>[A-Z]+)\\s+(?<manner>[A-Z]+)$/gmi),\n            match => [match[1], <`${ArticulationManner}`>match[2]]\n        )\n    );\n}\n\nexport function getSymbols(): string[] {\n    return read(\"cmudict.symbols\")\n        .match(/^\\S+$/gm)!;\n}\n\n// WTF does 'vp' mean?\nexport function getVP(): Map<string, Entry> {\n    return readPronunciations(\"cmudict.vp\", /^(?<name>[^A-Z\\s]+)(?<note>[^\\s()]+)?(?:\\((?<index>\\d+)\\))? (?<phonemes>(?:[A-Z]+[0-2]?(?: |$))+)/gmi);\n}\n\nexport * from \"./entry\";\nexport { ArticulationManner };\n"],"mappings":"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","names":["ArticulationManner"]}